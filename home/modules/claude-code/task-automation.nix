{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.claude-code-enhanced;
  taskCfg = cfg.taskAutomation;

  # Slash command for interactive task execution
  nextTaskMd = ''
    Read the plan file specified below (or auto-detect from CLAUDE.md if not specified),
    find the first task with status "TASK:PENDING" in the Progress Tracking table,
    execute it following the task definition in that file,
    document findings in the corresponding section,
    change status from "TASK:PENDING" to "TASK:COMPLETE" and add today's date,
    and report what you completed and what's next.
    Commit your changes when done.

    Plan file: $ARGUMENTS

    If no plan file argument is provided:
    1. Check the project's CLAUDE.md for a "Primary File" or "Plan File" reference
    2. Look for files matching `*-research.md`, `*-plan.md`, or `*-tasks.md` in docs/
    3. Ask the user which file to use

    IMPORTANT: If you determine the task cannot be executed on the current host
    (e.g., requires Nix but running on Termux, or requires specific tools not available),
    say "ENVIRONMENT_NOT_CAPABLE" and explain briefly. Do NOT mark the task complete -
    leave it PENDING for another host to pick up.

    CRITICAL: Do NOT invent "alternative approaches" or workarounds to tasks.
    If a task has prerequisites that aren't met (e.g., "test the Nix-generated package"
    but the package hasn't been built), that task is ENVIRONMENT_NOT_CAPABLE.
    Complete the task as defined or mark it not capable - no workarounds.

    After completing the task, provide a summary:

    ## Task Completed
    - **Task ID**: [task number/name]
    - **Status**: Complete
    - **Summary**: [1-2 sentence summary]

    ## Next Pending Task
    - **Task ID**: [next task number/name]
    - **Description**: [brief description]

    If no pending tasks remain, output "ALL_TASKS_DONE"
  '';

  # Generate the run-tasks script with configurable limits
  runTasksScript = pkgs.writeShellScriptBin "run-tasks" ''
    #!/usr/bin/env bash
    #
    # run-tasks - Claude Code unattended task runner
    # Generated by: home/modules/claude-code/task-automation.nix
    #
    # Usage: run-tasks <plan-file> [options]
    #
    # Runs claude -p to execute tasks defined in a markdown plan file.
    # The plan file must have a Progress Tracking table with "TASK:PENDING" status markers.

    set -euo pipefail

    # Colors
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'

    # Configurable defaults (from Nix options)
    LOG_DIR="${taskCfg.logDirectory}"
    STATE_FILE="${taskCfg.stateFile}"
    DELAY_BETWEEN_TASKS=${toString taskCfg.safetyLimits.delayBetweenTasks}
    RATE_LIMIT_WAIT=${toString taskCfg.safetyLimits.rateLimitWaitSeconds}
    MAX_RETRIES=${toString taskCfg.safetyLimits.maxRetries}
    MAX_ITERATIONS=${toString taskCfg.safetyLimits.maxIterations}
    MAX_RUNTIME_HOURS=${toString taskCfg.safetyLimits.maxRuntimeHours}
    MAX_CONSECUTIVE_RATE_LIMITS=${toString taskCfg.safetyLimits.maxConsecutiveRateLimits}
    START_TIME=$(date +%s)

    # Parse arguments
    PLAN_FILE=""
    MODE="single"
    COUNT=1
    DRY_RUN=false
    ACCOUNT=""  # Required: which account wrapper to use (max, pro, work)

    usage() {
        cat << 'EOF'
    run-tasks - Claude Code unattended task runner

    Usage: run-tasks -A <account> <plan-file> [options]

    Arguments:
      -A <account>      REQUIRED: Account to use (max, pro, work)
      <plan-file>       Path to markdown file with Progress Tracking table

    Options:
      -n N              Run N tasks (default: 1)
      -a, --all         Run all pending tasks
      -c, --continuous  Run continuously (survives rate limits)
      -d, --delay N     Seconds between tasks (default: ${toString taskCfg.safetyLimits.delayBetweenTasks})
      --dry-run         Show prompt without executing
      -h, --help        Show this help

    Account Selection:
      You MUST specify which account to use. This determines which Claude wrapper
      (claudemax, claudepro, claudework) is invoked with the correct configuration.

    Plan File Format:
      The plan file must contain a Progress Tracking table with unique status tokens:

      | Task | Name | Status | Date |
      |------|------|--------|------|
      | 1    | ...  | TASK:COMPLETE | 2026-01-10 |
      | 2    | ...  | TASK:PENDING  |      |

      Status tokens: TASK:PENDING, TASK:COMPLETE (unique to avoid false matches)

    Safety Limits (configurable via Nix):
      Max iterations:  ${toString taskCfg.safetyLimits.maxIterations}
      Max runtime:     ${toString taskCfg.safetyLimits.maxRuntimeHours} hours
      Rate limit wait: ${toString taskCfg.safetyLimits.rateLimitWaitSeconds} seconds

    Examples:
      run-tasks -A max docs/research-plan.md           # Run 1 task with max account
      run-tasks -A pro docs/research-plan.md -n 5      # Run 5 tasks with pro account
      run-tasks -A work docs/research-plan.md -a       # Run all pending with work account
      run-tasks -A max docs/research-plan.md -c        # Run continuously
      run-tasks -A max docs/research-plan.md --dry-run # Show prompt only
    EOF
        exit 0
    }

    # Parse positional and optional args
    while [[ $# -gt 0 ]]; do
        case $1 in
            -A|--account) ACCOUNT="$2"; shift 2 ;;
            -n) COUNT="$2"; MODE="count"; shift 2 ;;
            -a|--all) MODE="all"; shift ;;
            -c|--continuous) MODE="continuous"; shift ;;
            -d|--delay) DELAY_BETWEEN_TASKS="$2"; shift 2 ;;
            --dry-run) DRY_RUN=true; shift ;;
            -h|--help) usage ;;
            -*)
                echo -e "''${RED}Unknown option: $1''${NC}"
                echo "Use -h for help"
                exit 1
                ;;
            *)
                if [[ -z "$PLAN_FILE" ]]; then
                    PLAN_FILE="$1"
                else
                    echo -e "''${RED}Unexpected argument: $1''${NC}"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Validate account selection (REQUIRED)
    if [[ -z "$ACCOUNT" ]]; then
        echo -e "''${RED}Error: Account selection required (-A max|pro|work)''${NC}"
        echo ""
        echo "You must specify which account to use:"
        echo "  -A max   - Use Claude Max account (claudemax)"
        echo "  -A pro   - Use Claude Pro account (claudepro)"
        echo "  -A work  - Use Work Code-Companion account (claudework)"
        echo ""
        echo "Use -h for full help"
        exit 1
    fi

    # Map account name to wrapper command
    case "$ACCOUNT" in
        max)  CLAUDE_CMD="claudemax" ;;
        pro)  CLAUDE_CMD="claudepro" ;;
        work) CLAUDE_CMD="claudework" ;;
        *)
            echo -e "''${RED}Error: Unknown account '$ACCOUNT'${NC}"
            echo "Valid accounts: max, pro, work"
            exit 1
            ;;
    esac

    # Verify the claude wrapper exists
    if ! command -v "$CLAUDE_CMD" &>/dev/null; then
        echo -e "''${RED}Error: Claude wrapper '$CLAUDE_CMD' not found in PATH''${NC}"
        echo "Make sure home-manager has been activated with the account configured."
        exit 1
    fi

    # Validate plan file
    if [[ -z "$PLAN_FILE" ]]; then
        echo -e "''${RED}Error: Plan file required''${NC}"
        echo "Usage: run-tasks <plan-file> [options]"
        echo "Use -h for help"
        exit 1
    fi

    if [[ ! -f "$PLAN_FILE" ]]; then
        echo -e "''${RED}Error: Plan file not found: $PLAN_FILE''${NC}"
        exit 1
    fi

    # Resolve to absolute path
    PLAN_FILE_ABS=$(realpath "$PLAN_FILE")

    # Create log directory
    mkdir -p "$LOG_DIR"

    # Build the prompt
    PROMPT="Read ''${PLAN_FILE_ABS}, find the first task with status \"TASK:PENDING\" in the Progress Tracking table. Execute it following the task definition in that file. Document findings in the corresponding section. Change status from \"TASK:PENDING\" to \"TASK:COMPLETE\" and add today's date. Report what you completed and what's next. Commit your changes when done. If no TASK:PENDING found, say 'ALL_TASKS_DONE'. IMPORTANT: If you determine the task cannot be executed on the current host (e.g., requires Nix but running on Termux, or requires specific tools not available), say 'ENVIRONMENT_NOT_CAPABLE' and explain briefly. Do NOT mark the task complete - leave it PENDING for another host to pick up. CRITICAL: Do NOT invent 'alternative approaches' or workarounds to tasks. If a task has prerequisites that aren't met (e.g., 'test the Nix-generated package' but the package hasn't been built), that task is ENVIRONMENT_NOT_CAPABLE. Complete the task as defined or mark it not capable - no workarounds."

    # Functions
    pending_count() {
        ${pkgs.ripgrep}/bin/rg -c '\|\s*TASK:PENDING\s*\|' "$PLAN_FILE" 2>/dev/null || echo "0"
    }

    save_state() {
        local tasks_run=$1
        local status=$2
        local pending_now=''${3:-$(pending_count)}
        local runtime=$(($(date +%s) - START_TIME))
        cat > "$STATE_FILE" << EOF
    LAST_RUN=$(date -Iseconds)
    TASKS_RUN=$tasks_run
    STATUS=$status
    PENDING_NOW=$pending_now
    RUNTIME_SECONDS=$runtime
    PLAN_FILE=$PLAN_FILE_ABS
    EOF
    }

    format_runtime() {
        local seconds=$1
        local hours=$((seconds / 3600))
        local minutes=$(((seconds % 3600) / 60))
        local secs=$((seconds % 60))
        if [[ $hours -gt 0 ]]; then
            echo "''${hours}h ''${minutes}m"
        elif [[ $minutes -gt 0 ]]; then
            echo "''${minutes}m ''${secs}s"
        else
            echo "''${secs}s"
        fi
    }

    print_exit_summary() {
        local reason=$1
        local tasks_run=$2
        local pending=$3
        local runtime=$(($(date +%s) - START_TIME))
        local runtime_fmt=$(format_runtime $runtime)

        echo ""
        echo -e "''${CYAN}===============================================''${NC}"
        echo -e "''${CYAN}  Session Summary''${NC}"
        echo -e "''${CYAN}===============================================''${NC}"
        echo -e "  Reason:    ''${reason}"
        echo -e "  Tasks:     ''${tasks_run} completed, ''${pending} pending"
        echo -e "  Runtime:   ''${runtime_fmt}"
        echo -e "  Logs:      ''${LOG_DIR}/"
        echo -e "''${CYAN}===============================================''${NC}"
    }

    # Parse JSON output from Claude CLI
    # Returns: sets global variables json_type, json_subtype, json_is_error, json_result
    parse_claude_json() {
        local json_output="$1"

        # Extract key fields using jq
        json_type=$(echo "$json_output" | ${pkgs.jq}/bin/jq -r '.type // "unknown"' 2>/dev/null) || json_type="parse_error"
        json_subtype=$(echo "$json_output" | ${pkgs.jq}/bin/jq -r '.subtype // "unknown"' 2>/dev/null) || json_subtype="unknown"
        json_is_error=$(echo "$json_output" | ${pkgs.jq}/bin/jq -r '.is_error // false' 2>/dev/null) || json_is_error="true"
        json_result=$(echo "$json_output" | ${pkgs.jq}/bin/jq -r '.result // ""' 2>/dev/null) || json_result=""
    }

    # Detect rate limiting from JSON output or error text
    # Uses structured JSON fields when available, falls back to text patterns with word boundaries
    is_rate_limited() {
        local json_output="$1"
        local raw_stderr="$2"

        # Check JSON subtype first (most reliable)
        local subtype
        subtype=$(echo "$json_output" | ${pkgs.jq}/bin/jq -r '.subtype // ""' 2>/dev/null) || subtype=""
        if [[ "$subtype" == "rate_limited" || "$subtype" == "rate_limit" ]]; then
            return 0
        fi

        # Check for rate limit in result message
        local result
        result=$(echo "$json_output" | ${pkgs.jq}/bin/jq -r '.result // ""' 2>/dev/null) || result=""
        if echo "$result" | ${pkgs.ripgrep}/bin/rg -qi '\brate.?limit|too many requests|\b429\b|hit your.*limit'; then
            return 0
        fi

        # Check raw stderr for API errors (word boundaries to avoid false positives like line numbers)
        if echo "$raw_stderr" | ${pkgs.ripgrep}/bin/rg -qi '\b429\b|rate.?limit.*error|error.*rate.?limit|too many requests'; then
            return 0
        fi

        return 1
    }

    run_task() {
        local task_num=$1
        local rate_limit_count=''${2:-0}
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        local log_file="''${LOG_DIR}/task_''${timestamp}.log"
        local json_log_file="''${LOG_DIR}/task_''${timestamp}.json"
        local pending_before=$(pending_count)

        echo -e "\n''${CYAN}----------------------------------------------''${NC}"
        echo -e "''${GREEN}Task #''${task_num} | $(date '+%Y-%m-%d %H:%M:%S')''${NC}"
        echo -e "''${YELLOW}Pending: ''${pending_before} | Log: ''${log_file}''${NC}"
        echo -e "''${CYAN}----------------------------------------------''${NC}\n"

        if [[ "$DRY_RUN" == true ]]; then
            echo -e "''${YELLOW}[DRY RUN] Would execute:''${NC}"
            echo "$CLAUDE_CMD -p --output-format json --permission-mode bypassPermissions \"$PROMPT\""
            echo -e "''${YELLOW}Log would be: ''${log_file}''${NC}"
            return 0
        fi

        local json_output
        local raw_stderr
        local exit_code=0

        # Capture JSON output to stdout, stderr separately for error analysis
        # Using --output-format json for structured response parsing
        {
            json_output=$($CLAUDE_CMD -p --output-format json --permission-mode bypassPermissions "$PROMPT" 2>"''${log_file}.stderr")
            exit_code=$?
        } || exit_code=$?

        raw_stderr=$(cat "''${log_file}.stderr" 2>/dev/null || echo "")

        # Save both JSON and human-readable logs
        echo "$json_output" > "$json_log_file"

        # Create human-readable log with result text
        {
            echo "=== Task #''${task_num} - $(date '+%Y-%m-%d %H:%M:%S') ==="
            echo "Exit code: $exit_code"
            echo ""
            if [[ -n "$json_output" ]]; then
                echo "=== Claude Response ==="
                echo "$json_output" | ${pkgs.jq}/bin/jq -r '.result // "No result field"' 2>/dev/null || echo "$json_output"
            fi
            if [[ -n "$raw_stderr" ]]; then
                echo ""
                echo "=== Stderr ==="
                echo "$raw_stderr"
            fi
        } > "$log_file"

        # Parse JSON response
        parse_claude_json "$json_output"

        # PRIORITY 1: Check for startup/configuration errors (non-zero exit before JSON)
        # These indicate Claude couldn't even start properly
        if [[ $exit_code -ne 0 && "$json_type" == "parse_error" ]]; then
            echo -e "\n''${RED}Claude failed to start (exit: $exit_code)''${NC}"
            if [[ -n "$raw_stderr" ]]; then
                echo -e "''${RED}Error: $(echo "$raw_stderr" | head -3)''${NC}"
            fi

            # Check if it's a rate limit at the API level
            if is_rate_limited "$json_output" "$raw_stderr"; then
                local next_attempt=$((rate_limit_count + 1))
                echo -e "\n''${YELLOW}Rate limit detected (attempt ''${next_attempt}/''${MAX_CONSECUTIVE_RATE_LIMITS}). Waiting ''${RATE_LIMIT_WAIT}s...''${NC}"
                save_state "$task_num" "rate_limited" "$pending_before"
                sleep $RATE_LIMIT_WAIT
                return 2
            fi

            save_state "$task_num" "startup_error" "$pending_before"
            return 1
        fi

        # PRIORITY 2: Check JSON is_error field (most reliable for API errors)
        if [[ "$json_is_error" == "true" ]]; then
            echo -e "\n''${RED}Claude reported error: $json_subtype''${NC}"

            # Check for rate limiting via structured fields
            if is_rate_limited "$json_output" "$raw_stderr"; then
                local next_attempt=$((rate_limit_count + 1))
                echo -e "\n''${YELLOW}Rate limit detected (attempt ''${next_attempt}/''${MAX_CONSECUTIVE_RATE_LIMITS}). Waiting ''${RATE_LIMIT_WAIT}s...''${NC}"
                save_state "$task_num" "rate_limited" "$pending_before"
                sleep $RATE_LIMIT_WAIT
                return 2
            fi

            save_state "$task_num" "api_error_$json_subtype" "$pending_before"
            return 1
        fi

        # PRIORITY 3: Check protocol sentinels in result text (defined in our prompt)
        # These are reliable because we control the exact tokens

        # Environment not capable - skip this task, leave PENDING for another host
        if echo "$json_result" | ${pkgs.ripgrep}/bin/rg -q "ENVIRONMENT_NOT_CAPABLE"; then
            echo -e "\n''${YELLOW}Task cannot run on this host - leaving PENDING for another host''${NC}"
            save_state "$task_num" "environment_not_capable" "$pending_before"
            return 5
        fi

        # All tasks done
        if echo "$json_result" | ${pkgs.ripgrep}/bin/rg -q "ALL_TASKS_DONE"; then
            local pending_after=$(pending_count)
            if [[ "$pending_after" == "0" ]]; then
                echo -e "\n''${GREEN}Claude confirms all tasks complete''${NC}"
                save_state "$task_num" "all_complete" "$pending_after"
                return 3
            fi
        fi

        # PRIORITY 4: Success path - exit code 0 and type is "result" with subtype "success"
        if [[ $exit_code -eq 0 && "$json_type" == "result" && "$json_subtype" == "success" ]]; then
            local pending_after=$(pending_count)
            echo -e "\n''${GREEN}Task #''${task_num} complete (pending: ''${pending_before} -> ''${pending_after})''${NC}"
            save_state "$task_num" "complete" "$pending_after"
            return 0
        fi

        # PRIORITY 5: Non-zero exit code with valid JSON (task execution failed)
        if [[ $exit_code -ne 0 ]]; then
            echo -e "\n''${RED}Task #''${task_num} failed (exit: $exit_code, type: $json_type, subtype: $json_subtype)''${NC}"
            save_state "$task_num" "failed" "$pending_before"
            return 1
        fi

        # FALLBACK: Unexpected state - treat as success if we got here with exit 0
        local pending_after=$(pending_count)
        echo -e "\n''${YELLOW}Task #''${task_num} completed with unexpected response format''${NC}"
        save_state "$task_num" "complete_unexpected" "$pending_after"
        return 0
    }

    # Header
    echo -e "''${GREEN}"
    cat << 'BANNER'
    ╔═══════════════════════════════════════════════════════╗
    ║       Claude Code Task Runner                         ║
    ║       Ctrl+C to gracefully stop                       ║
    ╚═══════════════════════════════════════════════════════╝
    BANNER
    echo -e "''${NC}"

    echo "Plan file: $PLAN_FILE_ABS"
    echo "Account: $ACCOUNT ($CLAUDE_CMD)"
    echo "Mode: $MODE $([ "$MODE" = "count" ] && echo "($COUNT)")"
    INITIAL_PENDING=$(pending_count)
    echo "Pending tasks: $INITIAL_PENDING"
    echo "Delay: ''${DELAY_BETWEEN_TASKS}s"
    echo "Safety limits: ''${MAX_ITERATIONS} iterations, ''${MAX_RUNTIME_HOURS}h runtime"
    echo ""

    # Pre-flight validation
    if [[ "$INITIAL_PENDING" == "0" ]]; then
        echo -e "''${GREEN}No pending tasks found. Nothing to do.''${NC}"
        save_state "0" "no_pending" "0"
        exit 0
    fi

    # Validate plan file format
    if ! ${pkgs.ripgrep}/bin/rg -q '^\|\s*(Task|#)\s*\|' "$PLAN_FILE"; then
        echo -e "''${YELLOW}Warning: Plan file may not have standard Progress Tracking table''${NC}"
    fi

    if ${pkgs.ripgrep}/bin/rg -q '\|\s*Pending\s*\|' "$PLAN_FILE" && ! ${pkgs.ripgrep}/bin/rg -q '\|\s*TASK:PENDING\s*\|' "$PLAN_FILE"; then
        echo -e "''${YELLOW}Warning: Plan file uses 'Pending' instead of 'TASK:PENDING'''''${NC}"
        echo -e "''${YELLOW}Please update status tokens for reliable matching''${NC}"
    fi

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "''${YELLOW}=== DRY RUN MODE ===''${NC}"
        echo ""
    fi

    # Trap Ctrl+C
    trap 'pending_now=$(pending_count); print_exit_summary "Interrupted by user (Ctrl+C)" "$task_counter" "$pending_now"; save_state "$task_counter" "interrupted"; exit 130' INT

    # Main loop
    task_counter=0
    retries=0
    consecutive_rate_limits=0

    while true; do
        pending=$(pending_count)

        # Check: all complete
        if [[ "$pending" == "0" ]]; then
            print_exit_summary "All tasks completed successfully" "$task_counter" "0"
            save_state "$task_counter" "all_complete"
            exit 0
        fi

        # Check: max iterations
        if [[ $task_counter -ge $MAX_ITERATIONS ]]; then
            print_exit_summary "Iteration limit reached (''${MAX_ITERATIONS} tasks)" "$task_counter" "$pending"
            save_state "$task_counter" "max_iterations"
            exit 1
        fi

        # Check: max runtime
        runtime=$(($(date +%s) - START_TIME))
        max_runtime_seconds=$((MAX_RUNTIME_HOURS * 3600))
        if [[ $runtime -ge $max_runtime_seconds ]]; then
            print_exit_summary "Runtime limit reached (''${MAX_RUNTIME_HOURS} hours)" "$task_counter" "$pending"
            save_state "$task_counter" "max_runtime"
            exit 1
        fi

        # Check: mode limits
        if [[ "$MODE" == "single" && $task_counter -ge 1 ]]; then
            break
        fi

        if [[ "$MODE" == "count" && $task_counter -ge $COUNT ]]; then
            break
        fi

        task_counter=$((task_counter + 1))

        run_task $task_counter $consecutive_rate_limits
        result=$?

        case $result in
            0)  # Success
                retries=0
                consecutive_rate_limits=0
                ;;
            2)  # Rate limited
                task_counter=$((task_counter - 1))
                retries=$((retries + 1))
                consecutive_rate_limits=$((consecutive_rate_limits + 1))

                # Circuit breaker
                if [[ $consecutive_rate_limits -ge $MAX_CONSECUTIVE_RATE_LIMITS ]]; then
                    pending_now=$(pending_count)
                    print_exit_summary "Rate limit circuit breaker (''${MAX_CONSECUTIVE_RATE_LIMITS} consecutive)" "$task_counter" "$pending_now"
                    save_state "$task_counter" "rate_limit_circuit_breaker"
                    exit 1
                fi

                if [[ $retries -ge $MAX_RETRIES ]]; then
                    pending_now=$(pending_count)
                    print_exit_summary "Retry limit reached (''${MAX_RETRIES} attempts)" "$task_counter" "$pending_now"
                    save_state "$task_counter" "max_retries"
                    exit 1
                fi
                continue
                ;;
            3)  # All complete
                print_exit_summary "All tasks completed (confirmed by Claude)" "$task_counter" "0"
                exit 0
                ;;
            4)  # Permission required - user interaction needed
                task_counter=$((task_counter - 1))  # Don't count as attempt
                pending_now=$(pending_count)
                print_exit_summary "Stopped: Claude requires write permission" "$task_counter" "$pending_now"
                save_state "$task_counter" "permission_required"
                exit 1
                ;;
            5)  # Environment not capable - task requires different host
                task_counter=$((task_counter - 1))  # Don't count as attempt
                pending_now=$(pending_count)
                print_exit_summary "Task requires different host (ENVIRONMENT_NOT_CAPABLE)" "$task_counter" "$pending_now"
                save_state "$task_counter" "environment_not_capable"
                exit 0  # Exit cleanly - user should run on appropriate host
                ;;
            *)  # Failure
                retries=0
                consecutive_rate_limits=0
                echo -e "''${YELLOW}Continuing despite failure...''${NC}"
                ;;
        esac

        # Delay before next
        if [[ "$DRY_RUN" == true ]]; then
            break
        fi

        if [[ "$MODE" != "single" ]]; then
            remaining=$(pending_count)
            if [[ $remaining -gt 0 ]]; then
                echo -e "''${BLUE}Next task in ''${DELAY_BETWEEN_TASKS}s... ($remaining pending)''${NC}"
                sleep $DELAY_BETWEEN_TASKS
            fi
        fi
    done

    # Normal exit
    remaining=$(pending_count)
    print_exit_summary "Requested tasks completed" "$task_counter" "$remaining"
  '';

in
{
  options.programs.claude-code-enhanced.taskAutomation = {
    enable = mkEnableOption "Claude Code task automation (run-tasks script and /next-task command)";

    safetyLimits = {
      maxIterations = mkOption {
        type = types.int;
        default = 100;
        description = "Maximum number of task iterations before stopping";
      };

      maxRuntimeHours = mkOption {
        type = types.int;
        default = 8;
        description = "Maximum total runtime in hours";
      };

      maxConsecutiveRateLimits = mkOption {
        type = types.int;
        default = 5;
        description = "Circuit breaker threshold for consecutive rate limits";
      };

      rateLimitWaitSeconds = mkOption {
        type = types.int;
        default = 300;
        description = "Seconds to wait after hitting a rate limit";
      };

      maxRetries = mkOption {
        type = types.int;
        default = 3;
        description = "Maximum retries for a single task after rate limits";
      };

      delayBetweenTasks = mkOption {
        type = types.int;
        default = 10;
        description = "Seconds to wait between tasks";
      };
    };

    logDirectory = mkOption {
      type = types.str;
      default = ".claude-task-logs";
      description = "Directory for task execution logs (relative to current working directory)";
    };

    stateFile = mkOption {
      type = types.str;
      default = ".claude-task-state";
      description = "File for persisting task runner state (relative to current working directory)";
    };
  };

  config = mkIf (cfg.enable && taskCfg.enable) {
    # Add run-tasks script to user's packages
    home.packages = [ runTasksScript ];

    # Deploy /next-task slash command to each enabled account's commands/ directory
    home.file = mkMerge (
      mapAttrsToList
        (accountName: account:
          if account.enable then {
            "src/nixcfg/claude-runtime/.claude-${accountName}/commands/next-task.md" = {
              text = nextTaskMd;
            };
          } else { }
        )
        cfg.accounts
    );
  };
}
