{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.claude-code-enhanced;
  taskCfg = cfg.taskAutomation;

  # Slash command for interactive task execution
  nextTaskMd = ''
    Read the plan file specified below (or auto-detect from CLAUDE.md if not specified),
    find the first task with status "TASK:PENDING" in the Progress Tracking table,
    execute it following the task definition in that file,
    document findings in the corresponding section,
    change status from "TASK:PENDING" to "TASK:COMPLETE" and add today's date,
    and report what you completed and what's next.
    Commit your changes when done.

    Plan file: $ARGUMENTS

    If no plan file argument is provided:
    1. Check the project's CLAUDE.md for a "Primary File" or "Plan File" reference
    2. Look for files matching `*-research.md`, `*-plan.md`, or `*-tasks.md` in docs/
    3. Ask the user which file to use

    IMPORTANT: If you determine the task cannot be executed on the current host
    (e.g., requires Nix but running on Termux, or requires specific tools not available),
    say "ENVIRONMENT_NOT_CAPABLE" and explain briefly. Do NOT mark the task complete -
    leave it PENDING for another host to pick up.

    CRITICAL: Do NOT invent "alternative approaches" or workarounds to tasks.
    If a task has prerequisites that aren't met (e.g., "test the Nix-generated package"
    but the package hasn't been built), that task is ENVIRONMENT_NOT_CAPABLE.
    Complete the task as defined or mark it not capable - no workarounds.

    After completing the task, provide a summary:

    ## Task Completed
    - **Task ID**: [task number/name]
    - **Status**: Complete
    - **Summary**: [1-2 sentence summary]

    ## Next Pending Task
    - **Task ID**: [next task number/name]
    - **Description**: [brief description]

    If no pending tasks remain, output "ALL_TASKS_DONE"
  '';

  # Generate the run-tasks script with configurable limits
  runTasksScript = pkgs.writeShellScriptBin "run-tasks" ''
    #!/usr/bin/env bash
    #
    # run-tasks - Claude Code unattended task runner
    # Generated by: home/modules/claude-code/task-automation.nix
    #
    # Usage: run-tasks <plan-file> [options]
    #
    # Runs claude -p to execute tasks defined in a markdown plan file.
    # The plan file must have a Progress Tracking table with "TASK:PENDING" status markers.

    set -euo pipefail

    # Colors
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'

    # Configurable defaults (from Nix options)
    LOG_DIR="${taskCfg.logDirectory}"
    STATE_FILE="${taskCfg.stateFile}"
    DELAY_BETWEEN_TASKS=${toString taskCfg.safetyLimits.delayBetweenTasks}
    RATE_LIMIT_WAIT=${toString taskCfg.safetyLimits.rateLimitWaitSeconds}
    MAX_RETRIES=${toString taskCfg.safetyLimits.maxRetries}
    MAX_ITERATIONS=${toString taskCfg.safetyLimits.maxIterations}
    MAX_RUNTIME_HOURS=${toString taskCfg.safetyLimits.maxRuntimeHours}
    MAX_CONSECUTIVE_RATE_LIMITS=${toString taskCfg.safetyLimits.maxConsecutiveRateLimits}
    START_TIME=$(date +%s)

    # Parse arguments
    PLAN_FILE=""
    MODE="single"
    COUNT=1
    DRY_RUN=false

    usage() {
        cat << 'EOF'
    run-tasks - Claude Code unattended task runner

    Usage: run-tasks <plan-file> [options]

    Arguments:
      <plan-file>       Path to markdown file with Progress Tracking table

    Options:
      -n N              Run N tasks (default: 1)
      -a, --all         Run all pending tasks
      -c, --continuous  Run continuously (survives rate limits)
      -d, --delay N     Seconds between tasks (default: ${toString taskCfg.safetyLimits.delayBetweenTasks})
      --dry-run         Show prompt without executing
      -h, --help        Show this help

    Plan File Format:
      The plan file must contain a Progress Tracking table with unique status tokens:

      | Task | Name | Status | Date |
      |------|------|--------|------|
      | 1    | ...  | TASK:COMPLETE | 2026-01-10 |
      | 2    | ...  | TASK:PENDING  |      |

      Status tokens: TASK:PENDING, TASK:COMPLETE (unique to avoid false matches)

    Safety Limits (configurable via Nix):
      Max iterations:  ${toString taskCfg.safetyLimits.maxIterations}
      Max runtime:     ${toString taskCfg.safetyLimits.maxRuntimeHours} hours
      Rate limit wait: ${toString taskCfg.safetyLimits.rateLimitWaitSeconds} seconds

    Examples:
      run-tasks docs/research-plan.md           # Run 1 task
      run-tasks docs/research-plan.md -n 5      # Run 5 tasks
      run-tasks docs/research-plan.md -a        # Run all pending
      run-tasks docs/research-plan.md -c        # Run continuously
      run-tasks docs/research-plan.md --dry-run # Show prompt only
    EOF
        exit 0
    }

    # Parse positional and optional args
    while [[ $# -gt 0 ]]; do
        case $1 in
            -n) COUNT="$2"; MODE="count"; shift 2 ;;
            -a|--all) MODE="all"; shift ;;
            -c|--continuous) MODE="continuous"; shift ;;
            -d|--delay) DELAY_BETWEEN_TASKS="$2"; shift 2 ;;
            --dry-run) DRY_RUN=true; shift ;;
            -h|--help) usage ;;
            -*)
                echo -e "''${RED}Unknown option: $1''${NC}"
                echo "Use -h for help"
                exit 1
                ;;
            *)
                if [[ -z "$PLAN_FILE" ]]; then
                    PLAN_FILE="$1"
                else
                    echo -e "''${RED}Unexpected argument: $1''${NC}"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Validate plan file
    if [[ -z "$PLAN_FILE" ]]; then
        echo -e "''${RED}Error: Plan file required''${NC}"
        echo "Usage: run-tasks <plan-file> [options]"
        echo "Use -h for help"
        exit 1
    fi

    if [[ ! -f "$PLAN_FILE" ]]; then
        echo -e "''${RED}Error: Plan file not found: $PLAN_FILE''${NC}"
        exit 1
    fi

    # Resolve to absolute path
    PLAN_FILE_ABS=$(realpath "$PLAN_FILE")

    # Create log directory
    mkdir -p "$LOG_DIR"

    # Build the prompt
    PROMPT="Read ''${PLAN_FILE_ABS}, find the first task with status \"TASK:PENDING\" in the Progress Tracking table. Execute it following the task definition in that file. Document findings in the corresponding section. Change status from \"TASK:PENDING\" to \"TASK:COMPLETE\" and add today's date. Report what you completed and what's next. Commit your changes when done. If no TASK:PENDING found, say 'ALL_TASKS_DONE'. IMPORTANT: If you determine the task cannot be executed on the current host (e.g., requires Nix but running on Termux, or requires specific tools not available), say 'ENVIRONMENT_NOT_CAPABLE' and explain briefly. Do NOT mark the task complete - leave it PENDING for another host to pick up. CRITICAL: Do NOT invent 'alternative approaches' or workarounds to tasks. If a task has prerequisites that aren't met (e.g., 'test the Nix-generated package' but the package hasn't been built), that task is ENVIRONMENT_NOT_CAPABLE. Complete the task as defined or mark it not capable - no workarounds."

    # Functions
    pending_count() {
        ${pkgs.ripgrep}/bin/rg -c '\|\s*TASK:PENDING\s*\|' "$PLAN_FILE" 2>/dev/null || echo "0"
    }

    save_state() {
        local tasks_run=$1
        local status=$2
        local pending_now=''${3:-$(pending_count)}
        local runtime=$(($(date +%s) - START_TIME))
        cat > "$STATE_FILE" << EOF
    LAST_RUN=$(date -Iseconds)
    TASKS_RUN=$tasks_run
    STATUS=$status
    PENDING_NOW=$pending_now
    RUNTIME_SECONDS=$runtime
    PLAN_FILE=$PLAN_FILE_ABS
    EOF
    }

    format_runtime() {
        local seconds=$1
        local hours=$((seconds / 3600))
        local minutes=$(((seconds % 3600) / 60))
        local secs=$((seconds % 60))
        if [[ $hours -gt 0 ]]; then
            echo "''${hours}h ''${minutes}m"
        elif [[ $minutes -gt 0 ]]; then
            echo "''${minutes}m ''${secs}s"
        else
            echo "''${secs}s"
        fi
    }

    print_exit_summary() {
        local reason=$1
        local tasks_run=$2
        local pending=$3
        local runtime=$(($(date +%s) - START_TIME))
        local runtime_fmt=$(format_runtime $runtime)

        echo ""
        echo -e "''${CYAN}===============================================''${NC}"
        echo -e "''${CYAN}  Session Summary''${NC}"
        echo -e "''${CYAN}===============================================''${NC}"
        echo -e "  Reason:    ''${reason}"
        echo -e "  Tasks:     ''${tasks_run} completed, ''${pending} pending"
        echo -e "  Runtime:   ''${runtime_fmt}"
        echo -e "  Logs:      ''${LOG_DIR}/"
        echo -e "''${CYAN}===============================================''${NC}"
    }

    run_task() {
        local task_num=$1
        local rate_limit_count=''${2:-0}
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        local log_file="''${LOG_DIR}/task_''${timestamp}.log"
        local pending_before=$(pending_count)

        echo -e "\n''${CYAN}----------------------------------------------''${NC}"
        echo -e "''${GREEN}Task #''${task_num} | $(date '+%Y-%m-%d %H:%M:%S')''${NC}"
        echo -e "''${YELLOW}Pending: ''${pending_before} | Log: ''${log_file}''${NC}"
        echo -e "''${CYAN}----------------------------------------------''${NC}\n"

        if [[ "$DRY_RUN" == true ]]; then
            echo -e "''${YELLOW}[DRY RUN] Would execute:''${NC}"
            echo "claude -p \"$PROMPT\""
            echo -e "''${YELLOW}Log would be: ''${log_file}''${NC}"
            return 0
        fi

        local output
        local exit_code=0

        output=$(claude -p --permission-mode bypassPermissions "$PROMPT" 2>&1 | tee "$log_file") || exit_code=$?

        # SUCCESS PATH: exit code 0
        if [[ $exit_code -eq 0 ]]; then
            if echo "$output" | ${pkgs.ripgrep}/bin/rg -q "ALL_TASKS_DONE|no TASK:PENDING found"; then
                local pending_after=$(pending_count)
                if [[ "$pending_after" == "0" ]]; then
                    echo -e "\n''${GREEN}Claude confirms all tasks complete''${NC}"
                    save_state "$task_num" "all_complete" "$pending_after"
                    return 3
                fi
            fi

            local pending_after=$(pending_count)
            echo -e "\n''${GREEN}Task #''${task_num} complete (pending: ''${pending_before} -> ''${pending_after})''${NC}"
            save_state "$task_num" "complete" "$pending_after"
            return 0
        fi

        # FAILURE PATH: check for rate limit
        if echo "$output" | ${pkgs.ripgrep}/bin/rg -qi "(error|failed|rejected|denied|exceeded|http|status).*rate.?limit|rate.?limit.*(error|exceeded|reached)|too many requests|429|hit your.*limit"; then
            local next_attempt=$((rate_limit_count + 1))
            echo -e "\n''${YELLOW}Rate limit detected (attempt ''${next_attempt}/''${MAX_CONSECUTIVE_RATE_LIMITS}). Waiting ''${RATE_LIMIT_WAIT}s...''${NC}"
            save_state "$task_num" "rate_limited" "$pending_before"
            sleep $RATE_LIMIT_WAIT
            return 2
        fi

        # Permission issue - Claude is asking for write permission
        if echo "$output" | ${pkgs.ripgrep}/bin/rg -qi "need.*permission|waiting.*permission|grant.*permission|approve.*permission"; then
            echo -e "\n''${YELLOW}Permission required - user interaction needed, skipping''${NC}"
            save_state "$task_num" "permission_required" "$pending_before"
            return 4
        fi

        # Environment not capable - Claude detected it can't run this task on current host
        # Task stays PENDING for another host to pick up later
        if echo "$output" | ${pkgs.ripgrep}/bin/rg -qi "ENVIRONMENT_NOT_CAPABLE|cannot.*run.*on.*this.*host|requires.*nix|not.*available.*termux|environment.*not.*capable|skip.*this.*task.*host"; then
            echo -e "\n''${YELLOW}Environment not capable - task requires different host, skipping''${NC}"
            save_state "$task_num" "env_not_capable" "$pending_before"
            return 5
        fi

        # Other failure
        echo -e "\n''${RED}Task #''${task_num} failed (exit: $exit_code)''${NC}"
        save_state "$task_num" "failed" "$pending_before"
        return 1
    }

    # Header
    echo -e "''${GREEN}"
    cat << 'BANNER'
    ╔═══════════════════════════════════════════════════════╗
    ║       Claude Code Task Runner                         ║
    ║       Ctrl+C to gracefully stop                       ║
    ╚═══════════════════════════════════════════════════════╝
    BANNER
    echo -e "''${NC}"

    echo "Plan file: $PLAN_FILE_ABS"
    echo "Mode: $MODE $([ "$MODE" = "count" ] && echo "($COUNT)")"
    INITIAL_PENDING=$(pending_count)
    echo "Pending tasks: $INITIAL_PENDING"
    echo "Delay: ''${DELAY_BETWEEN_TASKS}s"
    echo "Safety limits: ''${MAX_ITERATIONS} iterations, ''${MAX_RUNTIME_HOURS}h runtime"
    echo ""

    # Pre-flight validation
    if [[ "$INITIAL_PENDING" == "0" ]]; then
        echo -e "''${GREEN}No pending tasks found. Nothing to do.''${NC}"
        save_state "0" "no_pending" "0"
        exit 0
    fi

    # Validate plan file format
    if ! ${pkgs.ripgrep}/bin/rg -q '^\|\s*(Task|#)\s*\|' "$PLAN_FILE"; then
        echo -e "''${YELLOW}Warning: Plan file may not have standard Progress Tracking table''${NC}"
    fi

    if ${pkgs.ripgrep}/bin/rg -q '\|\s*Pending\s*\|' "$PLAN_FILE" && ! ${pkgs.ripgrep}/bin/rg -q '\|\s*TASK:PENDING\s*\|' "$PLAN_FILE"; then
        echo -e "''${YELLOW}Warning: Plan file uses 'Pending' instead of 'TASK:PENDING'''${NC}"
        echo -e "''${YELLOW}Please update status tokens for reliable matching''${NC}"
    fi

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "''${YELLOW}=== DRY RUN MODE ===''${NC}"
        echo ""
    fi

    # Trap Ctrl+C
    trap 'pending_now=$(pending_count); print_exit_summary "Interrupted by user (Ctrl+C)" "$task_counter" "$pending_now"; save_state "$task_counter" "interrupted"; exit 130' INT

    # Main loop
    task_counter=0
    retries=0
    consecutive_rate_limits=0

    while true; do
        pending=$(pending_count)

        # Check: all complete
        if [[ "$pending" == "0" ]]; then
            print_exit_summary "All tasks completed successfully" "$task_counter" "0"
            save_state "$task_counter" "all_complete"
            exit 0
        fi

        # Check: max iterations
        if [[ $task_counter -ge $MAX_ITERATIONS ]]; then
            print_exit_summary "Iteration limit reached (''${MAX_ITERATIONS} tasks)" "$task_counter" "$pending"
            save_state "$task_counter" "max_iterations"
            exit 1
        fi

        # Check: max runtime
        runtime=$(($(date +%s) - START_TIME))
        max_runtime_seconds=$((MAX_RUNTIME_HOURS * 3600))
        if [[ $runtime -ge $max_runtime_seconds ]]; then
            print_exit_summary "Runtime limit reached (''${MAX_RUNTIME_HOURS} hours)" "$task_counter" "$pending"
            save_state "$task_counter" "max_runtime"
            exit 1
        fi

        # Check: mode limits
        if [[ "$MODE" == "single" && $task_counter -ge 1 ]]; then
            break
        fi

        if [[ "$MODE" == "count" && $task_counter -ge $COUNT ]]; then
            break
        fi

        task_counter=$((task_counter + 1))

        run_task $task_counter $consecutive_rate_limits
        result=$?

        case $result in
            0)  # Success
                retries=0
                consecutive_rate_limits=0
                ;;
            2)  # Rate limited
                task_counter=$((task_counter - 1))
                retries=$((retries + 1))
                consecutive_rate_limits=$((consecutive_rate_limits + 1))

                # Circuit breaker
                if [[ $consecutive_rate_limits -ge $MAX_CONSECUTIVE_RATE_LIMITS ]]; then
                    pending_now=$(pending_count)
                    print_exit_summary "Rate limit circuit breaker (''${MAX_CONSECUTIVE_RATE_LIMITS} consecutive)" "$task_counter" "$pending_now"
                    save_state "$task_counter" "rate_limit_circuit_breaker"
                    exit 1
                fi

                if [[ $retries -ge $MAX_RETRIES ]]; then
                    pending_now=$(pending_count)
                    print_exit_summary "Retry limit reached (''${MAX_RETRIES} attempts)" "$task_counter" "$pending_now"
                    save_state "$task_counter" "max_retries"
                    exit 1
                fi
                continue
                ;;
            3)  # All complete
                print_exit_summary "All tasks completed (confirmed by Claude)" "$task_counter" "0"
                exit 0
                ;;
            4)  # Permission required - user interaction needed
                task_counter=$((task_counter - 1))  # Don't count as attempt
                pending_now=$(pending_count)
                print_exit_summary "Stopped: Claude requires write permission" "$task_counter" "$pending_now"
                save_state "$task_counter" "permission_required"
                exit 1
                ;;
            5)  # Environment not capable - task requires different host
                task_counter=$((task_counter - 1))  # Don't count as attempt
                pending_now=$(pending_count)
                print_exit_summary "Task requires different host (ENVIRONMENT_NOT_CAPABLE)" "$task_counter" "$pending_now"
                save_state "$task_counter" "environment_not_capable"
                exit 0  # Exit cleanly - user should run on appropriate host
                ;;
            *)  # Failure
                retries=0
                consecutive_rate_limits=0
                echo -e "''${YELLOW}Continuing despite failure...''${NC}"
                ;;
        esac

        # Delay before next
        if [[ "$DRY_RUN" == true ]]; then
            break
        fi

        if [[ "$MODE" != "single" ]]; then
            remaining=$(pending_count)
            if [[ $remaining -gt 0 ]]; then
                echo -e "''${BLUE}Next task in ''${DELAY_BETWEEN_TASKS}s... ($remaining pending)''${NC}"
                sleep $DELAY_BETWEEN_TASKS
            fi
        fi
    done

    # Normal exit
    remaining=$(pending_count)
    print_exit_summary "Requested tasks completed" "$task_counter" "$remaining"
  '';

in {
  options.programs.claude-code-enhanced.taskAutomation = {
    enable = mkEnableOption "Claude Code task automation (run-tasks script and /next-task command)";

    safetyLimits = {
      maxIterations = mkOption {
        type = types.int;
        default = 100;
        description = "Maximum number of task iterations before stopping";
      };

      maxRuntimeHours = mkOption {
        type = types.int;
        default = 8;
        description = "Maximum total runtime in hours";
      };

      maxConsecutiveRateLimits = mkOption {
        type = types.int;
        default = 5;
        description = "Circuit breaker threshold for consecutive rate limits";
      };

      rateLimitWaitSeconds = mkOption {
        type = types.int;
        default = 300;
        description = "Seconds to wait after hitting a rate limit";
      };

      maxRetries = mkOption {
        type = types.int;
        default = 3;
        description = "Maximum retries for a single task after rate limits";
      };

      delayBetweenTasks = mkOption {
        type = types.int;
        default = 10;
        description = "Seconds to wait between tasks";
      };
    };

    logDirectory = mkOption {
      type = types.str;
      default = ".claude-task-logs";
      description = "Directory for task execution logs (relative to current working directory)";
    };

    stateFile = mkOption {
      type = types.str;
      default = ".claude-task-state";
      description = "File for persisting task runner state (relative to current working directory)";
    };
  };

  config = mkIf (cfg.enable && taskCfg.enable) {
    # Add run-tasks script to user's packages
    home.packages = [ runTasksScript ];

    # Deploy /next-task slash command to each enabled account's commands/ directory
    home.file = mkMerge (
      mapAttrsToList (accountName: account:
        if account.enable then {
          "src/nixcfg/claude-runtime/.claude-${accountName}/commands/next-task.md" = {
            text = nextTaskMd;
          };
        } else {}
      ) cfg.accounts
    );
  };
}
