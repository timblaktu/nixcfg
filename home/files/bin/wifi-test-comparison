#!/usr/bin/env bash
# wifi-test-comparison - Automated test to compare ESP32 vs OpenWRT WiFi channel ranking
# Compares channel analysis results between ESP32 device and OpenWRT router

set -e

# Configuration
ESP32_DEVICE="${ESP32_DEVICE:-/dev/ttyFalconTX}"  # ESP32 serial device
DSP_PROJECT_PATH="${DSP_PROJECT_PATH:-/home/tim/src/dsp}"  # Path to DSP project
ROUTER_IP="${ROUTER_IP:-192.168.1.1}"        # OpenWRT router IP
REMOTE_USER="${REMOTE_USER:-root}"            # Router SSH user
# TEST_TIMEOUT=60                               # Timeout for each test phase (unused)
VERBOSE=false
OUTPUT_DIR="./wifi-test-results"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
ESP32_SAMPLE_MODE=false                       # Use sample ESP32 data for testing

# Color codes
# RED='\033[0;31m' # Unused variable
# GREEN='\033[0;32m' # Unused variable
# YELLOW='\033[1;33m' # Unused variable
# BLUE='\033[0;34m' # Unused variable
# NC='\033[0m' # Unused variable

# Logging functions
log_info() { echo -e "$(date +%H:%M:%S.%3N) ℹ️  $1" >&2; }
log_success() { echo -e "$(date +%H:%M:%S.%3N) ✅ $1" >&2; }
log_warn() { echo -e "$(date +%H:%M:%S.%3N) ⚠️  $1" >&2; }
log_error() { echo -e "$(date +%H:%M:%S.%3N) ❌ $1" >&2; }
log_debug() { [ "$VERBOSE" = true ] && echo -e "$(date +%H:%M:%S.%3N) 🐞 $1" >&2; }

show_usage() {
    cat << EOF
WiFi Channel Ranking Comparison Test

USAGE:
    wifi-test-comparison [OPTIONS]

OPTIONS:
    -e DEVICE   ESP32 serial device (default: /dev/ttyFalconTX)
    -p PATH     DSP project path (default: /home/tim/src/dsp)
    -r IP       OpenWRT router IP (default: 192.168.1.1)
    -u USER     Router SSH user (default: root)
    -o DIR      Output directory (default: ./wifi-test-results)
    -t SECONDS  Test timeout (default: 60)
    -s          Use sample ESP32 data for testing
    -v          Verbose output
    -h          Show this help

EXAMPLES:
    # Basic comparison test
    wifi-test-comparison
    
    # Use sample ESP32 data (for testing without ESP32)
    wifi-test-comparison -s
    
    # Custom serial device and router IP with verbose output
    wifi-test-comparison -e /dev/ttyUSB0 -r 10.0.0.1 -v
    
    # Save results to specific directory
    wifi-test-comparison -o /tmp/wifi-tests

REQUIREMENTS:
    - ESP32 device connected via serial (or use -s for testing)
    - DSP project with make flashcap target available
    - OpenWRT router with remote-wifi-analyzer deployed
    - SSH access to router

OUTPUT:
    Creates timestamped directory with:
    - esp32-scan.json: ESP32 scan results
    - router-scan.json: Router scan results  
    - comparison-report.json: Analysis comparison
    - test-summary.txt: Human-readable summary
EOF
}

# Parse command line arguments
parse_args() {
    while getopts "e:p:r:u:o:t:svh" opt; do
        case $opt in
            e) ESP32_DEVICE="$OPTARG" ;;
            p) DSP_PROJECT_PATH="$OPTARG" ;;
            r) ROUTER_IP="$OPTARG" ;;
            u) REMOTE_USER="$OPTARG" ;;
            o) OUTPUT_DIR="$OPTARG" ;;
            t) : ;; # TEST_TIMEOUT option removed (unused)
            s) ESP32_SAMPLE_MODE=true ;;
            v) VERBOSE=true ;;
            h) show_usage; exit 0 ;;
            *) show_usage; exit 1 ;;
        esac
    done
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check DSP project and nixdev.sh only if not using sample mode
    if [ "$ESP32_SAMPLE_MODE" = false ]; then
        if [ ! -f "$DSP_PROJECT_PATH/nixdev.sh" ]; then
            log_error "nixdev.sh not found at $DSP_PROJECT_PATH/nixdev.sh"
            exit 1
        fi
        if [ ! -d "$DSP_PROJECT_PATH/mainproj" ]; then
            log_error "mainproj directory not found at $DSP_PROJECT_PATH/mainproj"
            exit 1
        fi
    fi
    
    # Check remote-wifi-analyzer
    if ! command -v remote-wifi-analyzer >/dev/null 2>&1 && ! [ -f "./remote-wifi-analyzer-fixed" ]; then
        log_error "remote-wifi-analyzer not found - please ensure it's in PATH or use the fixed version"
        exit 1
    fi
    
    # Test ESP32 serial device (skip in sample mode)
    if [ "$ESP32_SAMPLE_MODE" = false ]; then
        log_debug "Checking ESP32 serial device at $ESP32_DEVICE..."
        if [ ! -c "$ESP32_DEVICE" ]; then
            log_error "ESP32 serial device $ESP32_DEVICE not found (use -s for sample mode)"
            exit 1
        fi
    fi
    
    # Test router connectivity
    log_debug "Testing router connectivity to $ROUTER_IP..."
    if ! ping -c 1 -W 2 "$ROUTER_IP" >/dev/null 2>&1; then
        log_error "Cannot reach router at $ROUTER_IP"
        exit 1
    fi
    
    log_success "Prerequisites check passed"
}

# Create output directory
setup_output() {
    local test_dir="$OUTPUT_DIR/$TIMESTAMP"
    mkdir -p "$test_dir"
    cd "$test_dir"
    log_info "Test results will be saved to: $(pwd)"
}

# Generate sample ESP32 data for testing
generate_sample_esp32_data() {
    cat << 'EOF'
ESP32 WiFi scan completed successfully: 3 APs found
W (3134) wifi:(itwt)itwt_stop_process!
I (3134) wifi:mode : softAP (30:ed:a0:e4:0c:e9)
---> endeavour_perform_scan(): Restored WiFi mode to 2
---> swt_channel_rank_init(): Found 3 total APs
---> Channel 36 Penalty: 56 AP Primaries: 3
---> Channel 40 Penalty: 31 AP Primaries: 0
---> Channel 44 Penalty: 28 AP Primaries: 0
---> Channel 48 Penalty: 25 AP Primaries: 0
---> Channel 149 Penalty: 12 AP Primaries: 0
---> Channel 153 Penalty: 12 AP Primaries: 0
---> Channel 157 Penalty: 12 AP Primaries: 0
---> Channel 161 Penalty: 12 AP Primaries: 0
---> Channel 165 Penalty: 12 AP Primaries: 0
---> Channel 169 Penalty: 0 AP Primaries: 0
---> Channel 173 Penalty: 0 AP Primaries: 0
---> Channel 177 Penalty: 0 AP Primaries: 0
Initial channel ranking: (higher=better, scale 1 to 12)
[CHANNEL =  36][RANK =  1]
[CHANNEL =  40][RANK =  2]
[CHANNEL =  44][RANK =  3]
[CHANNEL =  48][RANK =  4]
[CHANNEL = 149][RANK =  9]
[CHANNEL = 153][RANK =  9]
[CHANNEL = 157][RANK =  9]
[CHANNEL = 161][RANK =  9]
[CHANNEL = 165][RANK =  9]
[CHANNEL = 169][RANK = 12]
[CHANNEL = 173][RANK = 12]
[CHANNEL = 177][RANK = 12]
Visual Channel Ranking (Taller = better):
                                      []  []  []
                                      []  []  []
                                      []  []  []
                  []  []  []  []  []  []  []  []
                  []  []  []  []  []  []  []  []
                  []  []  []  []  []  []  []  []
                  []  []  []  []  []  []  []  []
                  []  []  []  []  []  []  []  []
              []  []  []  []  []  []  []  []  []
          []  []  []  []  []  []  []  []  []  []
      []  []  []  []  []  []  []  []  []  []  []
  []  []  []  []  []  []  []  []  []  []  []  []
________________________________________________
  36  40  44  48  149 153 157 161 165 169 173 177
------------------------------------------------
---> swt_channel_rank_init(): Channel ranking initialization completed successfully
---> swt_channel_rank_get_next_channel(): Chose channel from rank: 169
---> swt_wifi_init_ap(): Channel ranking selected 169, updating from initial
EOF
}

# Trigger ESP32 WiFi scan and get results
get_esp32_results() {
    log_info "Getting ESP32 WiFi scan and channel ranking..."
    
    local esp32_data=""
    
    if [ "$ESP32_SAMPLE_MODE" = true ]; then
        log_debug "Using sample ESP32 data for testing"
        esp32_data=$(generate_sample_esp32_data)
    else
        # Get real ESP32 data via serial capture
        log_info "Executing ESP32 flash and capture via nixdev.sh..."
        
        local capture_file="$DSP_PROJECT_PATH/flashmoncap.log"
        local temp_capture="/tmp/esp32_capture_$$"
        
        # Change to DSP project directory and run make flashcap
        cd "$DSP_PROJECT_PATH"
        
        # Execute make flashcap through nixdev.sh
        if ./nixdev.sh make flashcap SWT_RUNTIME_PLATFORM=FALCON SERIAL_DEVICE="$ESP32_DEVICE" CAPTURE_DURATION=20s > "$temp_capture" 2>&1; then
            log_debug "ESP32 flash and capture completed successfully"
            
            # Check if capture file was created
            if [ -f "$capture_file" ] && [ -s "$capture_file" ]; then
                esp32_data=$(cat "$capture_file")
                log_debug "Captured $(wc -l < "$capture_file") lines from ESP32 serial output"
            else
                log_error "Capture file $capture_file was not created or is empty"
                echo "Make output:" >&2
                cat "$temp_capture" >&2
                rm -f "$temp_capture"
                return 1
            fi
        else
            log_error "ESP32 flash and capture failed"
            echo "Make output:" >&2
            cat "$temp_capture" >&2
            rm -f "$temp_capture"
            return 1
        fi
        
        rm -f "$temp_capture"
        
        # Verify we got channel ranking data
        if [ -z "$esp32_data" ] || ! echo "$esp32_data" | grep -q "Channel.*Penalty"; then
            log_error "ESP32 capture did not contain expected channel ranking data"
            echo "Captured data preview:" >&2
            echo "$esp32_data" | head -20 >&2
            return 1
        fi
        
        # Return to original directory
        cd - >/dev/null
    fi
    
    # Convert to JSON format for comparison
    convert_esp32_to_json "$esp32_data" > esp32-scan.json
    log_success "ESP32 results saved to esp32-scan.json"
}

# Convert ESP32 text output to JSON format
convert_esp32_to_json() {
    local esp32_output="$1"
    
    cat << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "device_type": "ESP32C5",
  "device_serial": "$ESP32_DEVICE",
  "scan_results": {
EOF
    
    # Extract total APs
    local total_aps
    total_aps=$(echo "$esp32_output" | grep "Found.*total APs" | grep -o '[0-9]\+' | head -1)
    [ -z "$total_aps" ] && total_aps=0
    echo "    \"total_aps\": $total_aps,"
    
    echo "    \"channels\": ["
    
    # Parse channel penalty data and ranking data
    local first=true
    
    # Extract channel penalties and rankings
    local temp_penalties="/tmp/esp32_penalties_$$"
    local temp_rankings="/tmp/esp32_rankings_$$"
    
    echo "$esp32_output" | grep "Channel.*Penalty:" > "$temp_penalties"
    echo "$esp32_output" | grep "\\[CHANNEL.*\\]\\[RANK.*\\]" > "$temp_rankings"
    
    # Process channels that have penalty data
    while IFS= read -r penalty_line; do
        if [ -z "$penalty_line" ]; then continue; fi
        
        [ "$first" = true ] && first=false || echo ","
        
        local channel
        channel=$(echo "$penalty_line" | grep -o "Channel [0-9]\+" | grep -o "[0-9]\+")
        local penalty
        penalty=$(echo "$penalty_line" | grep -o "Penalty: [0-9]\+" | grep -o "[0-9]\+")
        local ap_primaries
        ap_primaries=$(echo "$penalty_line" | grep -o "AP Primaries: [0-9]\+" | grep -o "[0-9]\+")
        
        # Get ranking for this channel
        local rank
        rank=$(grep "CHANNEL.*$channel" "$temp_rankings" | grep -o "RANK.*[0-9]\+" | grep -o "[0-9]\+" | head -1)
        [ -z "$rank" ] && rank=0
        
        # Calculate score (12 - rank + 1, so rank 1 = score 12, rank 12 = score 1)
        local score=0
        if [ "$rank" -gt 0 ]; then
            score=$((13 - rank))
        fi
        
        cat << EOF
      {
        "channel": $channel,
        "penalty": $penalty,
        "ap_primaries": $ap_primaries,
        "rank": $rank,
        "score": $score
      }
EOF
    done < "$temp_penalties"
    
    # Clean up temp files
    rm -f "$temp_penalties" "$temp_rankings"
    
    cat << EOF

    ]
  },
  "best_channel": $(echo "$esp32_output" | grep "Chose channel from rank:" | grep -o "[0-9]\+" | tail -1 || echo "null")
}
EOF
}

# Get OpenWRT router scan results
get_router_results() {
    log_info "Getting OpenWRT router channel analysis..."
    
    # Determine which analyzer to use
    local analyzer_cmd="remote-wifi-analyzer"
    if [ -f "./remote-wifi-analyzer-fixed" ]; then
        analyzer_cmd="bash ./remote-wifi-analyzer-fixed"
    fi
    
    # Use analyzer to get channel ranking
    if $analyzer_cmd scan-rank -b 5g -f json -o router-scan.json; then
        log_success "Router results saved to router-scan.json"
    else
        log_error "Failed to get router channel analysis"
        return 1
    fi
}

# Compare results and generate report
compare_results() {
    log_info "Comparing ESP32 vs Router channel rankings..."
    
    if [ ! -f esp32-scan.json ] || [ ! -f router-scan.json ]; then
        log_error "Missing scan result files for comparison"
        return 1
    fi
    
    # Create comparison script
    cat << 'EOF' > compare_channels.py
#!/usr/bin/env python3
import json
import sys
from datetime import datetime

def load_results():
    try:
        with open('esp32-scan.json', 'r') as f:
            esp32_data = json.load(f)
        with open('router-scan.json', 'r') as f:
            router_data = json.load(f)
        return esp32_data, router_data
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"Error loading JSON files: {e}", file=sys.stderr)
        sys.exit(1)

def normalize_to_percentile(values):
    """Convert values to percentile rankings (0-100)"""
    if not values or len(set(values)) == 1:
        return [50.0] * len(values)  # All same = median
    
    sorted_vals = sorted(values)
    percentiles = []
    for val in values:
        rank = sorted_vals.index(val)
        percentile = (rank / (len(sorted_vals) - 1)) * 100
        percentiles.append(percentile)
    return percentiles

def compare_rankings():
    esp32_data, router_data = load_results()
    
    # Extract channel data
    esp32_channels = esp32_data['scan_results']['channels']
    router_channels = router_data['channels']
    
    # Create channel lookups
    esp32_lookup = {ch['channel']: ch for ch in esp32_channels}
    router_lookup = {ch['channel']: ch for ch in router_channels}
    
    # Find common channels
    common_channels = sorted(set(esp32_lookup.keys()) & set(router_lookup.keys()))
    
    if not common_channels:
        return {"error": "No common channels found between devices"}
    
    # Get scores for normalization
    esp32_scores = [esp32_lookup[ch]['score'] for ch in common_channels]
    router_scores = [router_lookup[ch]['score'] for ch in common_channels]
    
    # Convert to percentiles for fair comparison
    esp32_percentiles = normalize_to_percentile(esp32_scores)
    router_percentiles = normalize_to_percentile(router_scores)
    
    # Compare rankings
    comparisons = []
    total_diff = 0
    
    for i, channel in enumerate(common_channels):
        esp32_ch = esp32_lookup[channel]
        router_ch = router_lookup[channel]
        
        esp32_perc = esp32_percentiles[i]
        router_perc = router_percentiles[i]
        
        diff = abs(esp32_perc - router_perc)
        total_diff += diff
        
        # Categorize agreement
        if diff < 15:
            agreement = "EXCELLENT"
        elif diff < 25:
            agreement = "GOOD"
        elif diff < 40:
            agreement = "FAIR"
        else:
            agreement = "POOR"
        
        comparisons.append({
            "channel": channel,
            "esp32": {
                "score": esp32_ch['score'],
                "rank": esp32_ch.get('rank', 0),
                "penalty": esp32_ch['penalty'],
                "ap_primaries": esp32_ch['ap_primaries'],
                "percentile": round(esp32_perc, 1)
            },
            "router": {
                "score": router_ch['score'],
                "ap_count": router_ch['ap_count'],
                "utilization": router_ch['utilization_percent'],
                "percentile": round(router_perc, 1)
            },
            "difference": round(diff, 1),
            "agreement": agreement
        })
    
    # Calculate metrics
    agreements = [c['agreement'] for c in comparisons]
    excellent_count = agreements.count('EXCELLENT')
    good_count = agreements.count('GOOD')
    fair_count = agreements.count('FAIR')
    poor_count = agreements.count('POOR')
    
    avg_diff = total_diff / len(comparisons)
    correlation_score = max(0, 100 - avg_diff)
    
    # Overall rating
    if correlation_score >= 85:
        overall_rating = "EXCELLENT"
    elif correlation_score >= 70:
        overall_rating = "GOOD"
    elif correlation_score >= 50:
        overall_rating = "FAIR"
    else:
        overall_rating = "POOR"
    
    # Find best channels
    esp32_best = max(esp32_channels, key=lambda x: x['score'])
    router_best = max(router_channels, key=lambda x: x['score'])
    
    return {
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "summary": {
            "total_channels": len(common_channels),
            "excellent_agreement": excellent_count,
            "good_agreement": good_count,
            "fair_agreement": fair_count,
            "poor_agreement": poor_count,
            "average_difference": round(avg_diff, 1),
            "correlation_score": round(correlation_score, 1),
            "overall_rating": overall_rating
        },
        "channel_comparisons": comparisons,
        "esp32_best_channel": esp32_best['channel'],
        "router_best_channel": router_best['channel'],
        "best_channel_match": esp32_best['channel'] == router_best['channel']
    }

if __name__ == "__main__":
    try:
        result = compare_rankings()
        with open('comparison-report.json', 'w') as f:
            json.dump(result, f, indent=2)
        print("Comparison completed successfully")
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
EOF
    
    if python3 compare_channels.py; then
        log_success "Comparison analysis completed"
        generate_summary_report
    else
        log_error "Failed to generate comparison analysis"
        return 1
    fi
}

# Generate human-readable summary
generate_summary_report() {
    if [ ! -f comparison-report.json ]; then
        log_error "Comparison report not found"
        return 1
    fi
    
    cat << 'EOF' > generate_summary.py
#!/usr/bin/env python3
import json

with open('comparison-report.json', 'r') as f:
    report = json.load(f)

if 'error' in report:
    print(f"Error: {report['error']}")
    exit(1)

summary = report['summary']
comparisons = report['channel_comparisons']

print("=" * 70)
print("WiFi Channel Ranking Comparison Test Results")
print("=" * 70)
print()
print(f"Test completed: {report['timestamp']}")
print(f"Channels analyzed: {summary['total_channels']}")
print()
print("Agreement Analysis:")
print(f"  Excellent (< 15% diff): {summary['excellent_agreement']} channels")
print(f"  Good (15-25% diff):     {summary['good_agreement']} channels")
print(f"  Fair (25-40% diff):     {summary['fair_agreement']} channels") 
print(f"  Poor (> 40% diff):      {summary['poor_agreement']} channels")
print()
print(f"Average Difference: {summary['average_difference']}%")
print(f"Correlation Score: {summary['correlation_score']}%")
print(f"Overall Rating: {summary['overall_rating']}")
print()
print("Best Channel Selection:")
print(f"  ESP32 best channel:  {report['esp32_best_channel']}")
print(f"  Router best channel: {report['router_best_channel']}")
if report['best_channel_match']:
    print("  ✅ Both devices agree on best channel!")
else:
    print("  ⚠️  Devices disagree on best channel")
print()
print("Detailed Channel Comparison:")
print("-" * 70)
print(f"{'Ch':<4} {'ESP32':<12} {'Router':<12} {'Diff':<7} {'Agreement':<12}")
print(f"{'':4} {'Score|Rank':<12} {'Score|Util':<12} {'(%)':<7} {'':<12}")
print("-" * 70)

for comp in sorted(comparisons, key=lambda x: x['channel']):
    ch = comp['channel']
    esp32_score = comp['esp32']['score']
    esp32_rank = comp['esp32']['rank']
    router_score = comp['router']['score']
    router_util = comp['router']['utilization']
    diff = comp['difference']
    agreement = comp['agreement']
    
    # Color coding for agreement
    if agreement == 'EXCELLENT':
        marker = '✅'
    elif agreement == 'GOOD':
        marker = '👍'
    elif agreement == 'FAIR':
        marker = '⚠️ '
    else:
        marker = '❌'
    
    print(f"{ch:<4} {esp32_score:>3}|{esp32_rank:>3}      {router_score:>3}|{router_util:>3}%     {diff:<6.1f} {marker} {agreement:<10}")

print()
# Test result
if summary['correlation_score'] >= 70:
    print("🎉 TEST PASSED: Channel ranking correlation is GOOD")
    print("   Both systems show similar channel quality assessment")
elif summary['correlation_score'] >= 50:
    print("⚠️  TEST MARGINAL: Channel ranking shows fair correlation")
    print("   Some differences in channel assessment detected")
else:
    print("❌ TEST FAILED: Significant differences in channel ranking")
    print("   Systems disagree substantially on channel quality")

print()
print("Interpretation:")
print("- Score: Higher values indicate better channels")
print("- Rank: ESP32 ranking (1=best, 12=worst)")
print("- Util: Router utilization percentage")
print("- Diff: Percentile difference between rankings")
EOF
    
    python3 generate_summary.py > test-summary.txt
    cat test-summary.txt
    log_success "Summary report saved to test-summary.txt"
}

# Main test execution
run_test() {
    log_info "Starting WiFi channel ranking comparison test"
    if [ "$ESP32_SAMPLE_MODE" = true ]; then
        log_info "Using sample ESP32 data, Router: $ROUTER_IP"
    else
        log_info "ESP32: $ESP32_DEVICE, Router: $ROUTER_IP"
    fi
    
    setup_output
    
    # Run both scans
    if ! get_esp32_results; then
        log_error "ESP32 scan failed"
        exit 1
    fi
    
    if ! get_router_results; then
        log_error "Router scan failed" 
        exit 1
    fi
    
    # Compare and report
    if ! compare_results; then
        log_error "Results comparison failed"
        exit 1
    fi
    
    log_success "Test completed successfully!"
    log_info "Results saved in: $(pwd)"
}

# Main entry point
main() {
    parse_args "$@"
    check_prerequisites
    run_test
}

main "$@"
