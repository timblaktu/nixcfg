searchState.loadedDescShard("rowan", 0, "A generic library for lossless syntax trees. See …\nOffset is exactly between two leaves.\nA checkpoint for maybe wrapping a node. See …\nFired before traversing the node.\nInternal node in the immutable tree. It has other nodes …\nA builder for a green tree.\nLeaf node in the immutable tree.\nFired after the node is traversed.\nInterner for GreenTokens and GreenNodes\nNo leaves at offset – possible for the empty file.\nOnly a single leaf at offset.\nSyntaxKind is a type tag for each token or node.\nPrimitives with a textual length that can be passed to …\nA range in text, represented as a pair of <code>TextSize</code>.\nA measure of text length. Also, equivalently, an index …\nThere might be zero, one or two leaves at a given offset.\n<code>WalkEvent</code> describes tree walking process.\nWorking with abstract syntax trees.\nCreate a new <code>TextRange</code> with the given <code>offset</code> and <code>len</code> (…\nAdd an offset to this range.\nChecked addition. Returns <code>None</code> if overflow occurred.\nSubtract an offset from this range.\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nPrepare for maybe wrapping the next node. The way wrapping …\nChildren of this node.\nCheck if this range contains an offset.\nCheck if this range contains an offset.\nCheck if this range completely contains another range.\nExtends the range to cover <code>other</code> as well.\nExtends the range to cover <code>other</code> offsets as well.\nImplementation of the cursors – API for convenient …\nCreate a zero-length range at the specified offset (…\nThe end point of this range.\nComplete tree building. Make sure that <code>start_node_at</code> and …\nFinish current branch and restore previous branch as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe range covered by both ranges, if it exists. If the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this range is empty.\nKind of this node.\nKind of this Token.\nReturns kind of this element.\nReturns kind of this element.\nConvert to option, preferring the left leaf in case of a …\nThe size of this range.\nCreates a new <code>TextRange</code> with the given <code>start</code> and <code>end</code> (…\nCreates a new instance of <code>TextSize</code> from a raw <code>u32</code>.\nCreates new Node.\nCreates new Token.\nCreates new builder.\nThe text size of some primitive text-like object.\nRelative order of the two ranges (overlapping ranges are …\nConvert to option, preferring the right leaf in case of a …\nThe start point of this range.\nStart new node and make it current.\nWrap the previous branch marked by <code>checkpoint</code> in a new …\nText of this Token.\nThe textual length of this primitive.\nReturns the length of the text covered by this node.\nReturns the length of the text covered by this token.\nReturns the length of the text covered by this element.\nReturns the length of the text covered by this element.\nAdds new token to the current branch.\nCreate a range up to the given end (<code>..end</code>).\nReusing <code>NodeCache</code> between different <code>GreenNodeBuilder</code>s …\nIterator over all the ancestors of this token excluding …\nFinds a <code>SyntaxElement</code> which intersects with a given <code>range</code>. …\nReturns an independent copy of the subtree rooted at this …\nReturn the deepest node or token in the current subtree …\nReturn the leftmost token in the subtree of this node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the rightmost token in the subtree of this node.\nNext token in the tree (i.e, not necessary a sibling).\nIterator over all the ancestors of this token excluding …\nTraverse the subtree rooted at the current node (including …\nTraverse the subtree rooted at the current node (including …\nPrevious token in the tree (i.e, not necessary a sibling).\nReturns a green tree, equal to the green tree this node …\nReturns a green tree, equal to the green tree this token …\nFind a token in the subtree corresponding to this node, …\nThe main trait to go from untyped <code>SyntaxNode</code> to a typed …\nLike <code>SyntaxNodePtr</code>, but remembers the type of node.\nA “pointer” to a <code>SyntaxNode</code>, via location in the …\nCasts this to an <code>AstPtr</code> to the given node type if possible.\nCasts this to an <code>AstPtr</code> to the given node type if possible.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the kind of the syntax node this points to.\nReturns an <code>AstPtr</code> for the node.\nReturns a <code>SyntaxNodePtr</code> for the node.\nReturns the underlying <code>SyntaxNodePtr</code>.\nReturns the range of the syntax node this points to.\nLike <code>Self::try_to_node</code> but panics on failure.\nLike <code>Self::try_to_node</code> but panics instead of returning <code>None</code>…\nGiven the root node containing the node <code>n</code> that <code>self</code> is a …\n“Dereferences” the pointer to get the <code>SyntaxNode</code> it …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")